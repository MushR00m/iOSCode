//
//  main.c
//  数据编码
//
//  Created by qianfeng on 14-7-15.
//  Copyright (c) 2014年 zhang. All rights reserved.
//

#include <stdio.h>
//
//计算机单位
// 最小单位是位(bit)
//   8bits = 1Byte
//   1Kb = 1024Bytes
//   1Mb = 1024Kb
//   1Gb = 1024Mb
//   1Tb = 1024Gb
//   1Pb = 1024Tb

//厂家
//500G = 500*1000Mb=500*1000*1000Kb
//
// 内存: 存储程序跟数据的地方

// 8bits
// 1111 1111
// 跟计算机约定: 最高位为符号位 最高位为 1 表示负数
// 最高位为 0 表示正数
// 6 : 0000 0110
// -6: 1000 0110
//原码: 最高位为符号位, 其余位表示绝对值大小
// 5 原码: 0000 0101
//-5 原码: 1000 0101
//    6+5`
//    0000 0110
//+   0000 0101
//-----------------
//    0000 1011 = 11`
//    6-5
//    6+(-5)
//    0000 0110
//+   1000 0101
//----------------
//    1000 1011  = -11
//
//原码不能参加运算: 因为符号位也参加了运算

//反码: 正数的反码就是它的原码,对于负数,符号位变,其余位按位取反
// -5 原码: 1000 0101   反码: 1111 1010
// -8 原码: 1000 1000   反码: 1111 0111
// -9 原码: 1000 1001   反码: 1111 0110
// -13原码: 1000 1101   反码: 1111 0010
// -17原码: 1001 0001   反码: 1110 1110

//  6+(-5)
//   0000 0110
// + 1111 1010
//-----------------
//   0000 0000(反码)   = 0000 0000 = 0
//
//反码转原码: 正数的原码就是它的反码,负数的原码是符号位不变,其余位按位取反
//
//  -6 -5
// (-6)+(-5)
//   1111 1001
//+  1111 1010
//----------------
//   1111 0011(反码) = 10001100 = -12
//反码作减法运算 , 得到的值总是比真实值少1
//
//补码: 对于正数来说,补码就是它的反码,也是它的原码,
//对于负数来说,补码是在反码的基础加1
// -6原码: 1000 0110 反码: 1111 1001 补码: 1111 1010
// -7原码: 1000 0111 反码: 1111 1000 补码: 1111 1001

// -6 +(-7)
//    1111 1010
//    1111 1001
//+--------------
//    1111 0011(补码)
//补码转原码: 对于正数, 补码的原码就是它本身, 对于负数,补码的原码,就是补码的反码 加1
// 1111 0011(补码) => 1000 1100(反码) => 1000 1101(原码)=-13
//
//正数的原码 反码 补码 都是一样的, 都是它的原码

//计算机采用补码的方式存储数据

// 8bits
//  0000 0000 -- 0111 1111   0 ~  127
//  1000 0000(补码) -- 1111 1111(补码)   -128 ~ 0
// +0 0000 0000
// -0 1000 0000   1000 0000
// -0 表示8bits范围内最小的数据
//对于-0来说 最高位的符号位即表示符号位,又表示绝对值大小


//-127 补码 : 1000 0001

// -23  原码: 10010111   反码: 1110 1000 补码: 1110 1001
// -11  原码: 1000 1011  反码: 1111 0100 补码: 1111 0101
// -45  原码: 1010 1101  反码: 1101 0010 补码: 1101 0011
// -34  原码: 1010 0010  反码: 1101 1101 补码; 1101 1110
//
// 数据类型
// char  short  int  long  long long
//
//sizeof() 求数据类型在内存空间中占用的大小  算出来的类型是long类型
//long long 类型的大小根据平台而定

// 64bits平台
// char  short    int   long    long long
//  1字节  2字节   4字节   8字节    8字节
//
// 32bits平台
// char   short    int    long   long long
// 1字节   2字节    4字节   4字节     8字节

//char -128 ~ 127
//int   -2^31(-2147483648) ~ 2^31-1(2147483647)
//short  -2^15  ~  2^15-1
//long  -2^63  ~  2^63-1
//long long -2^63 ~ 2^63-1;

/*int main(int argc, const char * argv[])
{
    printf("char == %ld\n", sizeof(char));//%ld 为一个占位符
    printf("int == %ld\n", sizeof(int));//\n表示换行
    printf("short == %ld\n", sizeof(short));
    printf("long == %ld\n",sizeof(long));
    printf("long long == %ld\n",sizeof(long long));
    
    return 0;
}*/

/*int main(int argc, const char *argv[])
{
    printf("int == %d ~~ %d\n", 0x80000000,0x7fffffff);
    printf("short == %d ~~ %d\n", (short)0x8000, (short)0x7fff);
    printf("long == %ld ~~ %ld\n", 0x8000000000000000,0x7fffffffffffffff);
//    short a = -12;
//    printf("%d\n", a);
    
    return 0;
}*/


//浮点型数据(实型数据)
//float  单精度浮点型
//double 双精度浮点型
//long double  长双精度浮点型

//3.14
//0.314 * 10^1(科学计数法)
//0.314e1(指数法)
//1. 符号位  2, 指数位 3, 小数位
//float 精度 6~7
//double 精度 15 ~16
//long double
/*int main(int argc, const char *argv[])
{
    printf("float == %ld\n",sizeof(float) );
    printf("double == %ld\n", sizeof(double));
    printf("long double == %ld\n", sizeof(long double));
    
    return 0;
}*/

//int main(int argc, const char *argv[])
//{
//    printf("%f\n",3.1444466665435353535);
//    printf("%.20lf\n",3.145667888998900000908766);
//    return 0;
//}

//常量: 常量是计算机中最基本的元素 整型常量 浮点型常量 字符常量 字符串常量 枚举常量
//如: 12   3.14   'a'   "qianfeng"
//
//变量:  int a = 12 ; a = 13;
//

/*int main(int argc, const char *argv[])
{
    int a=0;// "=" 赋值符号 "==" 表示等于
    printf("a = %d\n", a);
    a= 12;//赋值语句
    printf("a= %d\n", a);
    
    return 0;
}*/

int main(int argc, const char * argv[])
{
    int arr[32];
    int i =0 ;
    int a;
    scanf("%d", &a);
    while (a) {
        arr[i] = a%8;
        a/=8;
        i++;
    }
    for (i= i-1; i>=0; i--) {
        printf("%o", arr[i]);
    }
    printf("\n");
    return 0;
}